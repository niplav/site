[home](./index.md)
-------------------

*author: niplav, created: 2025-07-10, modified: 2025-08-22, language: english, status: in progress, importance: 3, confidence: likely*

> __.__

Pergraphs
==========

<!--TODO: incorporate
https://claude.ai/chat/43f2f7d1-278e-496f-8ad7-64688bd56a2d,
https://claude.ai/chat/acce955d-4c42-4dde-8c3e-0a9ef304e370-->

I am afflicted by a strange curse, which condemns me to be creative
enough to find new mathematical structures, but too dumb to prove anything
interesting about them.

![A drawing with the letter 'A' on the left side, the letter 'B' on the right side. A red arrow goes from 'A' to 'B'. A blue arrow goes from the middle of the red arrow to 'A'.](./img/pergraphs/garrabrant.png "A drawing with the letter 'A' on the left side, the letter 'B' on the right side. A red arrow goes from 'A' to 'B'. A blue arrow goes from the middle of the red arrow to 'A'.")

On a meditation retreat in 2022 I was remembering [a post by Scott
Garrabrant](https://www.lesswrong.com/posts/qhsELHzAHFebRJE59/a-greater-than-b-greater-than-a)
and doodled the above image in my notebook, together with
some other drawings of networks where edges can have edges as sources and sinks.

Formalizing
------------

Recently, I got thinking about those again, researched a bit and think
I've discovered they've not been examined yet. I'll call those kinds of
graphs or networks "pergraphs".

### Basic Definitions

__Intuition 1__: Intuitively, a __pergraph__ is a mathematical structure
consisting of nodes and edges (which I'll also equivalently call
__"peredges"__), where each edge needs to have a source and a sink. The
source and the sink of an edge can be any node or edge, including itself.

__Definition 1__: Given:

1. A finite set of vertices `$V$` and
2. A finite set of __peredges__ `$P$` (where a peredge is simply a label),

A __pergraph__ is the tuple `$(V, P, e: P \rightarrow (V \cup P) \times
(V \cup P))$`, where `$e$` is a function that assigns each __peredge__
a source and a sink.

Or, in [Lean 4](https://en.wikipedia.org/wiki/Lean_\(proof_assistant\)):

	inductive PerNode (V E : Type) : Type
	  | vertex : V → PerNode V E
	  | edge : E → PerNode V E

	structure Pergraph (V E : Type) where
	  e : E → PerNode V E × PerNode V E

__Remark 1__: A pergraph is more specifically a __*directed
multi-*pergraph__, since peredges are *directed*, and two peredges can
have the same source and the same sink. We will use the term "pergraph"
for directed multi-pergraphs, and specify deviations from such.

__Definition 2__: A __uni-pergraph__ is a pergraph with the additional constraint
that no two peredges have the same source *and* the same sink, mathematically
`$\lnot \exists p_1, p_2 \in P: p_1 \not=p_2 \land e(p_1)=e(p_2)$`.

### Some Pergraph Concepts

### Counting

Unlabeled pergraphs are counted up to isomorphism for renamings of
vertices and peredges.

One can count equence of pergraphs with `$n=|V|+|P|$` constituents,
starting at n=0:

1, 2, 15, 180, 3638, …

This sequence is not yet in the OEIS.

* For zero constituents there's only the empty pergraph `$(\emptyset, \emptyset)$`.
* For one constituent there's two pergraphs, the single node `$(\{v_1, \emptyset\})$` and the self-directed peredge `$(\emptyset, \{(e_1, e_1, e_1)\})$`.
* For two constituents there's these:

![](./img/pergraphs/two_small.png)

Code for computing the first terms of the sequence
[here](./code/pergraphs/simple.py), generated by Claude Sonnet 4,
which I can also thank for talking through all the cases for n=2.

As a variant one could ditch the nodes entirely, and replace them
self-sourced and self-sinked peredges. I think that one has different
combinatorial behavior.

<!--TODO: Compute maybe also for non-multi-pergraphs?-->

### Questions

1. When does reversing the peredges of a pergraph result in an isomorphic pergraph?
2. Is there some canonical injection into directed graphs?
3. How computationally expensive is isomorphism-checking?
	1. Sub-pergraph detection?
4. In general, what graph theory concepts could be ported over?
	1. Planarity? Strongly/weakly connected components?
5. Has really nobody looked at these before?
	1. What's the closest most specific but more general mathematical object that includes pergraphs as a special case?
6. What could these possibly be useful for?

Situating Pergraphs
--------------------

Pergraphs are *more general* than directed graphs (i.e. every
directed graph is a pergraph), and *less general* than
[2-categories](https://en.wikipedia.org/wiki/2-category)<!--TODO: check
with someone who knows a bit of category theory-->.

### Axes Along Which to Categorize Different Graph Concepts

{directed, undirected} edges×{allows, disallows} [multi-edges](https://en.wikipedia.org/wiki/Multigraph)×{allows, disallows} [loops](https://en.wikipedia.org/wiki/Loop_\(graph_theory\))×{allows, disallows} [hyperedges](https://en.wikipedia.org/wiki/Hypergraph)×{allows, disallows} edges between other edges×{allows, disallows} edges from/to themselves×{allows, disallows} edges between arbitrary sets of vertices.

### Prior Art

Pergraphs are distinct from
[hypergraphs](https://en.wikipedia.org/wiki/Hypergraph), as they
don't allow for an edge between more than two nodes; they are *not*
[multigraphs](https://en.wikipedia.org/wiki/Multigraph), because they
allow for edges from/to edges (similar to multigraphs, they allow
for multiple edges between the same two nodes); they are distinct from
[higraphs](https://en.wikipedia.org/wiki/Higraph), as they don't allow for
edges to originate from collections of multiple nodes; they are different
from [Petri nets](https://en.wikipedia.org/wiki/Petri-Net), because they
don't have movable tokens; they are not the same as metagraphs, because
they again allow for edges between (nested) collections of nodes. They
are probably different from categories, because they're more specific
than categories and don't require composition, but I don't know enough
category theory to confirm that.

The closest I've found to this concept is in this
unsourced section on the [Wikipedia article on
hypergraphs](https://en.wikipedia.org/wiki/Hypergraph#Further_generalizations):

> Alternately, edges can be allowed to point at other edges, irrespective
of the requirement that the edges be ordered as directed, acyclic
graphs. This allows graphs with edge-loops, which need not contain
vertices at all. For example, consider the generalized hypergraph
consisting of two edges `$e_{1}$` and `$e_{2}$`, and zero vertices,
so that `$e_{1}=\{e_{2}\}$` and `$e_{2}=\{e_{1}\}$`. As this loop is
infinitely recursive, sets that are the edges violate the [axiom of
foundation](https://en.wikipedia.org/wiki/Axiom_of_Foundation). In
foundation](https://en.wikipedia.org/wiki/Axiom_of_Foundation). In
particular, there is no transitive closure of set membership
for such hypergraphs. Although such structures may seem strange
at first, they can be readily understood by noting that the
equivalent generalization of their Levi graph is no longer
[bipartite](https://en.wikipedia.org/wiki/Bipartite),
but is rather just some general [directed
graph](https://en.wikipedia.org/wiki/Directed_Graph).

> The generalized incidence matrix for such hypergraphs is, by
definition, a square matrix, of a rank equal to the total number
of vertices plus edges. Thus, for the above example, the [incidence
matrix](https://en.wikipedia.org/wiki/Incidence_matrix) is simply
>
> <div>
        $$\begin{pmatrix}
        0 & 1 \cr
        1 & 0 \cr
        \end{pmatrix}$$
</div>

The concept appears under-developed, and slightly different from what
I'm pointing at.

Acknowledgements
-----------------

Many thanks to Claude 4 Sonnet and Claude 4 Opus for several long
conversations which fleshed out the concept, help with learning Lean,
and help with writing the Rust code for the enumeration.
