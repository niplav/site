[home](./index.md)
------------------

*author: niplav, created: 2019-04-11, modified: 2019-06-28, language: english, status: in progress, importance: 2, confidence: log*

> __I have found that I have found great use in software
> recommendations by people who I respect, such as
> [gwern](https://www.gwern.net/Links#uses-this), the
> [suckless project](https://suckless.org/rocks/), and
> [cat-v.org](http://harmful.cat-v.org/software/). I hope that the
> recommendations presented here can provide a comparable utility to
> similarly-minded people.__

Uses This
=========

Software
--------

### List of Programs

TODO: links

* Operating system: [Void Linux](https://voidlinux.org/)
* Window manager: [dwm](https://dwm.suckless.org/)
* Terminal emulator: [st](https://st.suckless.org/)
* PDF reader: [mupdf](https://mupdf.com/)
* Browser: [firefox](https://www.mozilla.org/en-US/firefox/new/)
* Editor: [vis](https://github.com/martanne/vis)
* Calendar: [when](http://www.lightandmatter.com/when/when.html)
* Spaced repetition: [fulgurate](https://github.com/theq629/fulgurate)
* Version control: [git](https://git-scm.com/)
* Password manager: spm
* Code search: [ag](https://geoff.greer.fm/ag/)
* Music: [sad](http://git.2f30.org/sad/log.html)
* Videos: [mpv](https://mpv.io/)
* Programming languages:
	* [C](https://en.wikipedia.org/wiki/C_%28programming_language%29)
	* [Klong](http://t3x.org/klong/index.html)
	* [Myrddin](https://eigenstate.org/myrddin/)
	* [Lua](https://www.lua.org/)
	* [Scheme](https://en.wikipedia.org/wiki/Scheme_(programming_language))
	* [Forth](https://en.wikipedia.org/wiki/Forth_(programming_language))
	* [Standard ML](https://en.wikipedia.org/wiki/Standard_ML)
* Shell:
	* Interactive: [fish](https://fishshell.com/)
	* Scripting: [rc](https://en.wikipedia.org/wiki/Rc)
* Keyboard layout: [Neo 2](https://neo-layout.org/index_en.html)

### Criteria

My most important criteria for choosing software are simplicity,
consistency and durability.

Simplicity here means mostly [simplicity of
implementation](https://en.wikipedia.org/wiki/Worse_is_better), though
in reality there is very little difference between software with a simple
design&interface and software that only has a simple implementation. Most
of the time, simplicity can be roughly approximated in the total number
of [sloc](https://en.wikipedia.org/wiki/Source_lines_of_code) used to
implement the software.

Consistency is even more difficult to define and classify than simplicity.
Broadly speaking, consistency is dependent on symmetry (every input
method has a corresponding output method and vice versa, for example)
and generally a lack of "surprise" when using the software (that is,
most parts of the software are similar in structure, but not content,
to each other). A good example of inconsistency is found in programming
languages with a unary `+`, but not a unary `-`, or programs with vastly
different naming conventions.

Durability, by comparison, is quite easy to explain. It simply describes
the amount of [bit rot](https://en.wikipedia.org/wiki/Software_rot) that
occurs in the given software over time. This includes the probability
that it will be maintained for a long time, and the durability and number
of its dependencies. A good example for durable software is correct C
code. It still compiles and runs after decades of neglect, though often
not without warnings (platform specific C code is of course less durable).

As a result of this, the programs I use mostly come from the Unix/Linux
ecosystem.

Hardware
--------

I tend not to care very much about hardware, except for compatibility
problems. Nearly all of my computing could be done on a [Raspberry
Pi](https://en.wikipedia.org/wiki/Raspberry_Pi), or on a generic mildly
priced new laptop. I like the Raspberry Pi because of its ability to run
a wide variety of operating systems, but beyond that hardware is rarely
a bottleneck for me. I do care about keyboards, though.

### Keyboard

### Mouse

Coding Standards
----------------

### General Project Setup

### C

### Shell Scripting
