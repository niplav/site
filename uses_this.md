[home](./index.md)
------------------

*author: niplav, created: 2019-04-11, modified: 2019-05-24, language: english, status: notes, importance: 2, confidence: log*

> __I have found that I have found great use in software
> recommendations by people who I respect, such as
> [gwern](https://www.gwern.net/Links#uses-this), the
> [suckless project](https://suckless.org/rocks/), and
> [cat-v.org](http://harmful.cat-v.org/software/). I hope that the
> recommendations presented here can provide a comparable utility to
> similarly-minded people.__

Uses This
=========

Software
--------

### List of Programs

TODO: links

* Operating system: Void Linux
* Window manager: dwm
* Terminal emulator: st
* PDF reader: mupdf
* Browser: firefox
* Editor: vis
* Calendar: when
* Spaced repetition: fulgurate
* Version control: git
* Code search: ag
* Music: sad
* Videos: mpv
* Programming languages:
	* C
	* Klong
	* Myrddin
	* Lua
	* Scheme
	* Forth
	* Standard ML
* Shell:
	* Interactive: fish
	* Scripting: rc
* Keyboard layout: Neo 2

### Criteria

My most important criteria for choosing software are simplicity,
consistency and durability.

Simplicity here means mostly simplicity of implementation (TODO: link to
New Jersey style of software development), though in reality there is
very little difference between software with a simple design&interface
and software that only has a simple implementation. Most of the time,
simplicity can be roughly approximated in the total number of loc (TODO:
link here) used to implement the software.

Consistency is even more difficult to define and classify than simplicity.
Broadly speaking, consistency is dependent on symmetry (every input
method has a corresponding output method and vice versa, for example)
and generally a lack of "surprise" when using the software (that is,
most parts of the software are similar in structure, but not content,
to each other). A good example of inconsistency is found in programming
languages with a unary `+`, but not a unary `-`, or programs with vastly
different naming conventions.

Durability, by comparison, is quite easy to explain. It simply describes
the amount of bitrot (TODO: link to wikipedia here) that occurs in
the given software over time. This includes the probability that it
will be maintained for a long time, and the durability and number
of its dependencies. A good example for durable software is correct
C code. It still compiles and runs after decades of neglect, though
often not without warnings (platform specific C code is of course
less durable).

Hardware
--------

I tend not to care very much about hardware, except for compatability
problems. Nearly all of my computing could be done on a Raspberry Pi
(TODO: link here), or on a generic mildly priced new laptop. I like the
Raspberry Pi because of its ability to run a wide variety of operating
systems, but beyond that hardware is rarely a bottleneck for me. I do
care about keyboards, though.

### Keyboard

### Mouse
