[home](./index.md)
------------------

*author: niplav, created: 2019-04-11, modified: 2022-03-28, language: english, status: in progress, importance: 2, confidence: log*

> __I have found that I have found great use in software
> recommendations by people who I respect, such as
> [gwern](https://www.gwern.net/Links#uses-this), the
> [suckless project](https://suckless.org/rocks/), and
> [cat-v.org](http://harmful.cat-v.org/software/). I hope that the
> recommendations presented here can provide a comparable utility to
> similarly-minded people.__

Uses This
=========

Software
--------

### Computer Programs

* Operating system: [Void Linux](https://voidlinux.org/)
* Window manager: [dwm](https://dwm.suckless.org/)
* Terminal emulator: [st](https://st.suckless.org/)
* PDF reader: [mupdf](https://mupdf.com/)
* Browser: [firefox](https://www.mozilla.org/en-US/firefox/new/)
* Editor: [vis](https://github.com/martanne/vis)
* Calendar: [when](http://www.lightandmatter.com/when/when.html)
* [Spaced repetition](https://en.wikipedia.org/wiki/Spaced_Repetition): [fulgurate](https://github.com/theq629/fulgurate), [Anki](https://apps.ankiweb.net/index.html)
* [Internet relay chat](https://en.wikipedia.org/wiki/Internet_Relay_Chat): [ii](https://tools.suckless.org/ii/) with [lchat](https://github.com/younix/lchat)
* [Twtxt](https://github.com/buckket/twtxt): [txtnish](https://github.com/mdom/txtnish)
* Version control: [git](https://git-scm.com/)
* Password manager: [spm](https://notabug.org/kl3/spm/)
* Code search: [ag](https://geoff.greer.fm/ag/)
* Music: [sad](http://git.2f30.org/sad/log.html)
* Videos: [mpv](https://mpv.io/)
* Shell:
	* Interactive: [fish](https://fishshell.com/)
	* Scripting: [rc](https://en.wikipedia.org/wiki/Rc)
* Keyboard layout: [Neo 2](https://neo-layout.org/index_en.html)

#### Programming languages:

* [C](https://en.wikipedia.org/wiki/C_%28programming_language%29)
* [Klong](http://t3x.org/klong/index.html)
* [Myrddin](https://eigenstate.org/myrddin/)
* [Lua](https://www.lua.org/)
* [Scheme](https://en.wikipedia.org/wiki/Scheme_\(programming_language\))
* [Standard ML](https://en.wikipedia.org/wiki/Standard_ML)
* [Python](https://www.python.org)

### Browser Plugins

* [Ublock Origin](https://addons.mozilla.org/en-US/firefox/addon/ublock-origin/)
* [Leechblock](https://www.proginosko.com/leechblock/)
* [NoScript](https://addons.mozilla.org/en-US/firefox/addon/noscript/)
* [Reddit Enhancement Suite](https://redditenhancementsuite.com/)
* [Tree Style Tab](https://addons.mozilla.org/en-US/firefox/addon/tree-style-tab)
* [HTTPS Everywhere](https://www.eff.org/https-everywhere)
* [Privacy Badger](https://privacybadger.org/)

### Smartphone Apps

* [Mood Patterns](https://www.moodpatterns.info)
* [Medativo](https://play.google.com/store/apps/details?id=com.despdev.meditationapp&hl=en&gl=US)
* [Tally Counter](https://play.google.com/store/apps/details?id=de.cliff.strichliste&hl=en&gl=us)
* [Beeminder](https://play.google.com/store/apps/details?id=com.beeminder.beeminder&hl=en&gl=us)

### Criteria

My most important criteria for choosing software are simplicity,
consistency and durability.

[Simplicity](https://plato.stanford.edu/entries/simplicity/) here means mostly [simplicity of
implementation](https://en.wikipedia.org/wiki/Worse_is_better), though
in reality there is very little difference between software with a simple
design&interface and software that only has a simple implementation. Most
of the time, simplicity can be roughly approximated in the total number
of [sloc](https://en.wikipedia.org/wiki/Source_lines_of_code) used to
implement the software.

[Consistency](https://en.wikipedia.org/wiki/Consistency_\(user_interfaces\)#List_of_the_cognitive_dimensions)
is even more difficult to define and classify than simplicity.
Broadly speaking, consistency is dependent on symmetry (every input
method has a corresponding output method and vice versa, for example)
and generally a lack of "surprise" when using the software (that is,
most parts of the software are similar in structure, but not content,
to each other). A good example of inconsistency is found in programming
languages with a unary `+`, but not a unary `-`, or programs with vastly
different naming conventions. Perhaps consistency can be thought of as
a certain type of symmetry; if not that, then at least symmetry plays
a big role in consistent systems.

[Durability](https://en.wikipedia.org/wiki/Durability), by comparison,
is quite easy to explain. It simply describes the amount of [bit
rot](https://en.wikipedia.org/wiki/Software_rot) that occurs in the
given software over time. This includes the probability that it will
be maintained for a long time, and the durability and number of its
dependencies. A good example for durable software is correct C code. It
still compiles and runs after decades of neglect, though often not
without warnings (platform specific C code is of course less durable).

As a result of this, the programs I use mostly come from the
[Unix](https://en.wikipedia.org/wiki/Unix)/[Linux](https://en.wikipedia.org/wiki/Linux)
ecosystem.

Hardware
--------

I tend not to care very much about hardware, except for compatibility
problems. Nearly all of my computing could be done on a [Raspberry
Pi](https://en.wikipedia.org/wiki/Raspberry_Pi), or on a generic mildly
priced new laptop. I like the Raspberry Pi because of its ability to
run a wide variety of operating systems, beyond that hardware is rarely
a bottleneck for me. I do care about peripherals, though.

<!--
Devices:
Smartphone, Laptop, IPod Shuffle
-->

<!--
### Keyboard

### Mouse
-->
