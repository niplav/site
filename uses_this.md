[home](./index.md)
------------------

*author: niplav, created: 2019-04-11, modified: 2019-04-24, language: english, status: notes, importance: 2, confidence: log*

> __I have found that I have found great use in software recommendations by
> people who I respect, such as (TODO: put gwerns uses this and suckless'
> rocks page, and cat-v recommendations). I hope that the recommendations
> presented here can provide a comparable utility to similarly-minded
> people.__

Uses This
=========

Software
--------

### List of Programs

* Operating system: Void Linux
* Window manager: dwm
* Terminal emulator: st
* PDF reader: mupdf
* Browser: firefox
* Editor: vis
* Calendar: when
* Spaced repetition: fulgurate
* Version control: git
* Code search: ag
* Music: sad
* Videos: mpv
* Programming languages:
	* C
	* Klong
	* Myrddin
	* Lua
	* Scheme
	* Forth
	* Standard ML
* Shell:
	* Interactive: fish
	* Scripting: rc
* Keyboard layout: Neo 2

### Criteria

My most important criteria for choosing software are simplicity,
consistency and durability.

Simplicity here means mostly simplicity of implementation (TODO: link
to New Jersey style of software development), though in reality there is
very little difference between software with a simple design&interface and
software that has a simple implementation. Most of the time, simplicity
can be roughly approximated in the total number of loc (TODO: link here)
used to implement the software.

Consistency is even more difficult to define and classify than simplicity.
Broadly speaking, consistency is dependent on symmetry (every input
method has a corresponding output method and vice versa, for example)
and generally a lack of "surprise" when using the software (that is,
most parts of the software are similar in structure, but not content,
to each other). A good example of inconsistency is found in programming
languages with a unary `+`, but not a unary `-`, or programs with vastly
different naming conventions.

Durability, by comparison, is quite easy to explain. It simply describes
the amount of bitrot (TODO: link to wikipedia here) that occurs in
the given software over time. This includes the probability that it
will be maintained for a long time, and the durability and number
of its dependencies. A good example for durable software is correct
C code. It still compiles and runs after decades of neglect, though
often not without warnings (platform specific C code is of course
less durable).

Hardware
--------
